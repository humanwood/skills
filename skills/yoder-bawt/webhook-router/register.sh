#!/bin/bash
#
# Webhook Source Registration Script
# Registers a new webhook source and generates configuration
#

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HANDLERS_DIR="${SCRIPT_DIR}/handlers"
CONFIG_DIR="${SCRIPT_DIR}/.config"

# Default values
FUNNEL_URL="${FUNNEL_URL:-https://gregs-mac-mini.taila31444.ts.net}"
HOOK_TOKEN="${HOOK_TOKEN:-19e78f0288d476ee1197d4b374b6f73394abe121c12cc38a}"

# Ensure directories exist
mkdir -p "$CONFIG_DIR"

show_help() {
    cat << 'EOF'
Usage: register.sh <source-type> <name> [OPTIONS]

Register a new webhook source and generate handler configuration.

Arguments:
  source-type    Type of webhook source (github, stripe, custom, etc.)
  name          Identifier name for this source (e.g., my-repo, payments)

Options:
  --handler      Create a custom handler template for this source
  --event-types  Comma-separated list of event types (default: generic)
  -h, --help    Show this help message

Examples:
  # Register GitHub webhook for a repository
  register.sh github my-awesome-app

  # Register Stripe webhook
  register.sh stripe payments

  # Register custom service with handler template
  register.sh myapp production --handler

  # Register with specific event types
  register.sh jenkins builds --event-types build.started,build.completed,build.failed

EOF
}

# Parse arguments
if [[ $# -lt 2 ]]; then
    show_help
    exit 1
fi

SOURCE_TYPE="$1"
NAME="$2"
shift 2

CREATE_HANDLER=false
EVENT_TYPES="generic"

while [[ $# -gt 0 ]]; do
    case $1 in
        --handler)
            CREATE_HANDLER=true
            shift
            ;;
        --event-types)
            EVENT_TYPES="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            show_help
            exit 1
            ;;
    esac
done

# Generate unique source identifier
# Format: <type>-<normalized-name>
NORMALIZED_NAME=$(echo "$NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd 'a-z0-9_-')
SOURCE_ID="${SOURCE_TYPE}-${NORMALIZED_NAME}"

# Generate unique token for this source (optional extra validation)
SOURCE_TOKEN=$(openssl rand -hex 16 2>/dev/null || head -c 32 /dev/urandom | xxd -p | tr -d '\n')

# Save registration
REGISTRATION_FILE="${CONFIG_DIR}/${SOURCE_ID}.json"
REGISTRATION=$(jq -n \
    --arg id "$SOURCE_ID" \
    --arg type "$SOURCE_TYPE" \
    --arg name "$NAME" \
    --arg token "$SOURCE_TOKEN" \
    --arg created "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
    --arg events "$EVENT_TYPES" \
    '{
        source_id: $id,
        source_type: $type,
        name: $name,
        token: $token,
        created_at: $created,
        event_types: ($events | split(",")),
        active: true
    }')

echo "$REGISTRATION" > "$REGISTRATION_FILE"

# Generate webhook URL
WEBHOOK_URL="${FUNNEL_URL}/hooks?source=${SOURCE_ID}"

# Create handler template if requested
if [[ "$CREATE_HANDLER" == "true" ]]; then
    HANDLER_FILE="${HANDLERS_DIR}/${SOURCE_TYPE}.sh"
    
    if [[ -f "$HANDLER_FILE" ]]; then
        echo "Note: Handler for '$SOURCE_TYPE' already exists at $HANDLER_FILE"
    else
        # Generate handler template
        cat > "$HANDLER_FILE" << 'HANDLER_TEMPLATE'
#!/bin/bash
#
# Handler for {{SOURCE_TYPE}} webhooks
# Auto-generated by register.sh
#

set -euo pipefail

PAYLOAD="$1"
SOURCE="$2"
EVENT_TYPE="${3:-unknown}"

ALERT_CHANNEL="${WEBHOOK_ALERT_CHANNEL:-telegram}"
VAULT_SECTION="webhooks/{{SOURCE_TYPE}}"

# Helper functions
send_alert() {
    local title="$1"
    local body="$2"
    echo "ALERT: $title - $body"
    if command -v message &> /dev/null; then
        message send "$ALERT_CHANNEL" "$title" <<< "$body" 2>/dev/null || true
    fi
}

write_to_vault() {
    local path="$1"
    local content="$2"
    local tags="$3"
    if command -v vault &> /dev/null; then
        vault write "$path" --data "$content" --tags "$tags" 2>/dev/null || true
    fi
}

TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# TODO: Add your parsing logic here
# Example: Extract fields from payload
# FIELD=$(echo "$PAYLOAD" | jq -r '.field // "unknown"')

# Log to vault
VAULT_CONTENT=$(jq -n \
    --arg ts "$TIMESTAMP" \
    --arg source "$SOURCE" \
    --arg event "$EVENT_TYPE" \
    --arg payload "$PAYLOAD" \
    '{
        timestamp: $ts,
        source: $source,
        event_type: $event,
        payload: $payload
    }')

write_to_vault "${VAULT_SECTION}/${SOURCE}/${TIMESTAMP}" "$VAULT_CONTENT" "{{SOURCE_TYPE}},webhook"

# TODO: Add event-specific handling
# case "$EVENT_TYPE" in
#     event.name)
#         # Handle specific event
#         send_alert "Event occurred" "Details here"
#         ;;
# esac

echo "Processed {{SOURCE_TYPE}} webhook: $EVENT_TYPE from $SOURCE"
exit 0
HANDLER_TEMPLATE

        # Replace template variables
        sed -i.bak "s/{{SOURCE_TYPE}}/${SOURCE_TYPE}/g" "$HANDLER_FILE" && rm -f "${HANDLER_FILE}.bak"
        chmod +x "$HANDLER_FILE"
        
        echo "Created handler template: $HANDLER_FILE"
    fi
fi

# Output configuration
cat << EOF

╔════════════════════════════════════════════════════════════════╗
║           Webhook Source Registered Successfully               ║
╠════════════════════════════════════════════════════════════════╣
║ Source ID:      ${SOURCE_ID}
║ Source Type:    ${SOURCE_TYPE}
║ Name:           ${NAME}
╠════════════════════════════════════════════════════════════════╣
║ Webhook URL:    ${WEBHOOK_URL}
╠════════════════════════════════════════════════════════════════╣
║ Headers to configure:
║   X-Hook-Token: ${HOOK_TOKEN}
║   Content-Type: application/json
╠════════════════════════════════════════════════════════════════╣
║ Registration saved to: ${REGISTRATION_FILE}
╚════════════════════════════════════════════════════════════════╝

Configuration Instructions:
───────────────────────────
1. In your ${SOURCE_TYPE} service, add a webhook with:
   
   URL: ${WEBHOOK_URL}
   
   Headers:
     X-Hook-Token: ${HOOK_TOKEN}
     Content-Type: application/json

2. Test the webhook:
   ./test.sh ${SOURCE_ID}

3. View incoming webhooks:
   tail -f /Users/gregborden/.openclaw/workspace/memory/webhooks.jsonl | jq .

EOF

# Service-specific instructions
case "$SOURCE_TYPE" in
    github)
        cat << 'EOF'
GitHub-Specific Setup:
──────────────────────
1. Go to: Repository → Settings → Webhooks → Add webhook
2. Payload URL: (use URL above)
3. Content type: application/json
4. Secret: (leave blank - token is in header)
5. Select events you want to receive

Supported events: push, pull_request, issues, release, ping

EOF
        ;;
    stripe)
        cat << 'EOF'
Stripe-Specific Setup:
──────────────────────
1. Go to: Dashboard → Developers → Webhooks → Add endpoint
2. Endpoint URL: (use URL above)
3. Select events to listen for (e.g., payment_intent.succeeded)
4. Add header: X-Hook-Token (use token above)

Consider creating a stripe.sh handler for specific event processing.

EOF
        ;;
    gitlab)
        cat << 'EOF'
GitLab-Specific Setup:
──────────────────────
1. Go to: Project → Settings → Webhooks
2. URL: (use URL above)
3. Secret Token: (use token above)
4. Select triggers (Push, Merge requests, Issues, etc.)
5. Add header: X-Hook-Token (use token above)

EOF
        ;;
    docker|dockerhub)
        cat << 'EOF'
Docker Hub Setup:
─────────────────
1. Go to: Repository → Webhooks → Create Webhook
2. Webhook Name: openclaw
3. Webhook URL: (use URL above)
4. The generic handler will process these events

Consider creating a docker.sh handler for specific processing.

EOF
        ;;
esac

echo "Registration complete!"
